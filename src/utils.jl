
"""
    fround(x; sigdigits=2)
Formatted rounding to significant digits (omitting decimal point when appropriate). 
Returns rounded number as string.

"""
function fround(x; sigdigits=2)
    xround = string(round(x, sigdigits = sigdigits))
    if xround[end-1:end]==".0"
        xround = string(xround[1:end-2])
    end
    return xround
end

function _df_to_tex(df::AbstractDataFrame, fname::AbstractString; colnames::Union{Nothing,Vector{AbstractString}} = nothing)::Nothing

    tex_table = df |>
        x -> !isnothing(colnames) ? rename(x, colnames) : x |> 
        x -> latexify(x, env = :table, booktabs = true, latex = false, fmt = FancyNumberFormatter(3))   

    open(fname, "w") do f
        write(f, tex_table)
    end

    @info "Writing latex table to $fname"

    return nothing
end

function _as_table(p::ComponentArray; printtable = true)

    df = DataFrame(
        param = EcotoxSystems.ComponentArrays.labels(p), 
        value = vcat(p...)
    )

    if printtable
        show(df, allrows = true)
    end

    return df
end


function _assign_value_by_label!(p::ComponentArray, label::AbstractString, value::Any)::Nothing

    labels = ComponentArrays.labels(p)
    idx = findfirst(x -> x == label, labels)
    
    p[idx] = value

    return nothing
end


"""
    assign_values_from_file!(p::ComponentArray, file::AbstractString)::Nothing

Assign the values stored in `file` to parameter object `p`. 
Assumes that parameters given in `file` already have an entry in `p`.
Assumes that `file` follows the `posterior_summary` format as generated by `run_PMC!`. <br>

In particular, the entries in the column `param` have to match the parameter labels as return by `ComponentArrays.label(p)`.


## Arguments 

- `p`: A `ComponentArray` holding parameter values. 
- `path_to_posterior_summary`: Relative path to a `posterior_summary.csv`. 
- `exceptions`: A dictionary of functions, mapping parameter labels to alternative methods of assigning 

## Using the exceptions argument

The `exceptions` argument is useful if one of the estimated parameter values was not a scalar, but a parameter of a distribution. <br>
Typically this means that we have used a `Hyperdist` in our priors: 

```Julia 
prior = Prior(
    "spc.Z" => Hyperdist(
            σ -> truncated(Normal(1, σ), 0, Inf), 
            truncated(Normal(0.1, 0.1), 0, Inf)
            )
    )
```

This syntax is equivalent to fixing the population mean of parameter `Z` to 1, and only estimating its standard deviation `sigma`. 
The `posterior_summary.csv` will then contain an entry "spc.Z"`. 
When we subsequently use `assign_values_from_file!` to load parameters from the `posterior_summary.csv`, we can use the `exceptions` argument 
to make sure that the distribution is correctly re-constructed: 

```Julia
assign_values_from_file!(
    p, 
    "posterior_summary.csv"; 
    exceptions = Dict(
        "spc.Z" => x -> truncated(Normal(1, x)))
        )

```
"""
function assign_values_from_file!(
    p::ComponentArray, 
    path_to_posterior_summary::AbstractString; 
    exceptions::AbstractDict
    )::Nothing

    posterior_summary = CSV.read(path_to_posterior_summary, DataFrame)

    for (label,value) in zip(posterior_summary.param, posterior_summary.best_fit)
        if !(label in keys(exceptions))
            _assign_value_by_label!(p, label, value)
        else
            exceptions[label](p, label, value)
        end
    end

    return nothing
end
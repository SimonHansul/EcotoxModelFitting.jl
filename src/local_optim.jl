
#### %%%% Functions for frequentist optimization %%%% ####

"""
    define_objective_function(
        data::OrderedDict, 
        simulator::Function,
        lossfun::Function
    )::Function
  

Define an objective function based on `data`, `simulator`, `lossfun`. <br>
`simulator` and `lossfun` are assumed to be generated by `define_fitting_simulator` 
and `define_loss_function`, respectively.
"""
function define_objective_function(
    data::OrderedDict, 
    simulator::Function,
    lossfun::Function
    )::Function


    function objective_function(pvec; kwargs...)::Float64

        sim = simulator(pvec; kwargs...) 
        l = lossfun(data, sim)

        return l
    end

    return objective_function
end


function define_objective_function(f::ModelFit)

    return define_objective_function(
        f.data, 
        f.simulator,
        f.loss 
    )

end

"""
    run_optim!(
        f::ModelFit; 
        method = NelderMead(), 
        p0 = nothing, 
        kwargs...
        )

Perform optimization on fitting problem `f`. 
Supports gradient-free algorithms provided by [`Optim.jl`](https://julianlsolvers.github.io/Optim.jl/stable/), i.e. 

- Nelder-Mead 
- Simulated annealing w/ bounds
- Particle swarm optimization
"""
function run_optim!(
    f::ModelFit; 
    method = NelderMead(), 
    p0 = nothing, 
    kwargs...
    )

    if isnothing(p0)
        @info "No initial values given - taking prior modes"
        p0 = mode.(f.prior.dists)
    end

    obj = define_objective_function(f)
    opt = optimize(obj, p0, method = method, kwargs...)

    return opt
end